CI- Continious Integration

CD- Continious Delivery

# CI

CI → practice of continiously integrating code changes to a shared repo, often several times a day

Goal → to catch issues early before creating a big problem

involves using automated tests to verify that code changes don't break existing functionality or introduce new bugs.

CI pipelines also require regular maintenance to accommodate changes in the
code base, dependencies (such as APIs) and infrastructure

## Importance of CI

1. Earlier, more efficient error detection
2. Improved team collaboration
3. Accelerated software development
4. Reduced risk in the development process
5. Improved Transparency and Accountability → CI provides visibility into the state of the codebase at all times. 
6. Reduced Costs and Time
7. Faster Feedback

# CI Tools

Continuous Integration (CI) tools automate the process of integrating code changes, running tests, and deploying applications.

Essential →

1. Streamline workflows
2. improve code quality
3. Enable faster releases

## 3 popular CI tools:-

### Jenkins →

Jenkins is one of the most popular and widely used open-source CI tools. It is highly customizable, with a large ecosystem of plugins that support various stages of software development, from building and testing to deploying applications

**Advantages**:

1. Open-Source and Free
2. Extensibility: With over 1,800 plugins available, Jenkins can be extended to support a wide range of tools, languages, and environments.
3. Flexibility: Jenkins can be used on-premises or in the cloud and can integrate with almost any tool or technology used in software development
4. Scalability: Jenkins supports distributed builds, allowing the workload to be distributed across multiple machines, which is beneficial for large projects
5. Custom Pipelines: Jenkins provides the ability to create complex pipelines using the Jenkins Pipeline DSL, giving teams full control over their CI/CD processes

### Travis CI →

cloud-based CI tool that is particularly popular in the open-source community. It integrates well with GitHub and supports a wide range of programming languages.

**Advantages**:

1. Ease of Use: Travis CI is easy to set up and use, especially for GitHub projects. It requires minimal configuration, often just a `.travis.yml` file in the project repository
2. Integration with GitHub: Travis CI integrates seamlessly with GitHub, making it a great choice for projects hosted on this platform. It automatically triggers builds on every commit and pull request.
3. Cloud-Based: As a fully hosted solution, Travis CI eliminates the need for teams to manage their own CI infrastructure, saving time and resources.
4. Support for Multiple Languages: Travis CI supports many programming languages, including Ruby, Python, Node.js, Java, and more, making it versatile for different types of projects.
5. Open-Source Friendly: Travis CI offers free plans for open-source projects, making it accessible to the open-source community

### Circle CI

cloud-based CI tool that offers both hosted and on-premises solutions. It is known for its speed and performance, making it a popular choice for teams focused on quick and efficient CI/CD pipelines

Advantages

1. Speed: CircleCI is optimized for speed, with features like parallelism and containerization that help reduce build times.
2. Flexibility: CircleCI supports both cloud-based and self-hosted configurations, giving teams the flexibility to choose the option that best fits their needs
3. Advanced Docker Support: CircleCI has strong support for Docker, making it ideal for teams working with containerized applications 
4. Customizable Workflows: CircleCI allows teams to define complex workflows with multiple jobs that can run sequentially or in parallel, providing greater control over the CI/CD process 
5. Detailed Insights: CircleCI provides detailed build analytics and insights, helping teams optimize their pipelines and improve performance over time

# Difference Between Continious Delivery & Continious Deployment

## Continious Delivery

software development practice where code changes are automatically
built, tested, and prepared for a release to production. However, the deployment to production is done manually.

### Characteristics:

1. Automated Testing: Continuous Delivery involves extensive automated testing (unit, integration, system, and acceptance tests) to ensure that the code is always in a deployable state.
2. Manual Approval: Even though the code is ready for deployment at any time, the actual release to production requires manual approval or triggering. This step allows teams to review and decide when to
release the new code.
3. Release on Demand: With Continuous Delivery, the software can be released to production at any time. This allows for flexibility in deciding when to push new features or updates live.
4. Pipeline Integration: The Continuous Delivery pipeline integrates various stages of the development process, from code commit to production readiness, ensuring a consistent and reliable release process.

### Benefits:

1. Flexibility: Teams can choose the most appropriate time to deploy, aligning releases with business needs 
2. Control: Manual approval adds an extra layer of control, which can be important for critical or large-scale deployments. 
3. Reduced Risk: Because the code is always in a deployable state, the risk of introducing bugs in production is minimized.

**Example**
A team working on a financial application uses Continuous Delivery. The code passes all automated tests and is ready for production, but the team waits until a scheduled maintenance window to manually deploy the changes

# Continuous Deployment (CD)

extension of Continuous Delivery where every code change that passes automated tests is automatically deployed to production, without requiring manual approval.

### Key Characteristics

1. Fully Automated Pipeline: Continuous Deployment takes automation further by removing the manual approval step. Once the code passes all tests, it is automatically deployed to production.
2. High Frequency of Releases: Continuous Deployment allows for rapid, frequent releases to production, sometimes multiple times a day. This is particularly useful in environments where continuous updates are
beneficial, such as web services or SaaS platforms.
3. Immediate Feedback: Changes are immediately reflected in production, providing real-time feedback and allowing for quick iterations based on user input or monitoring data.
4. Robust Monitoring: Continuous Deployment requires robust monitoring and alerting systems in place to detect and respond to any issues that arise after deployment

### Benefits

1. Speed: Continuous Deployment maximizes the speed of delivering new features, bug fixes, and improvements to users.
2. Efficiency: It eliminates the bottleneck of manual approval, making the release process more efficient
3. Continuous Innovation: Teams can continuously innovate and release new features, staying ahead of competitors.

Example
A team developing a social media platform uses Continuous Deployment. Each new code commit that passes automated testing is deployed directly to production, allowing users to immediately experience new features and updates

## Key Difeerences

| Aspect | Continuous Delivery | Continuous Deployment |
| --- | --- | --- |
| Deployment Trigger | Manual Approval required before production deployment | Automatic deployment to production without manual intervention |
| Deployment Frequency | Deployment is flexible, controlled by the team | Deployment is continious and frequent, often multiple times a day |
| Release Control | Teams have control over when to deploy | Deployment is automatic, with less manual control |
| Use Case | Suitable for environemnts requiringmanual checks or compliance requirements | Ideal for environments that benefit from rapid and frequent updates, like SaaS or web platforms |
| Risk Management | Allows for additional manual checks and risk assessments before deploying | Requires strong automated testing and monitoring to mitigate risks in real-time |
| Complexity | Generally simpler to implement due to manual control points | requires a more advanced, fully automated pipeline with robust testing and monitoring |

# CD Tools (Jenkins, GitLab CI, Spinnaker)

crucial for automating and streamlining the software release process.

# Jenkins:

Open Source automation server that helps automate parts of the software development process related to building, testing, and deploying, facilitating continuous integration and continuous delivery (CI/CD)

## Key Components:

1. Jenkins Master: Central control unit that manages and coordinates jobs, schedules build tasks, & dispatches them to appropriate agents. It also provides the user interface and monitors job status.
2. Jenkins Agents (Slaves): Machines that perform the actual build tasks. Agents can be on different operating systems, allowing for a wide range of environments

### Jenkins Pipeline:

Pipeline as Code: Jenkins allows defining build processes with code using a Jenkinsfile. This file describes the stages and steps of the pipeline, enabling version control and easier replication of build environments

### Declarative vs Scripted Pipelines

1. Declarative: A simpler, structured approach with predefined syntax.
2. Scripted: More flexible and powerful, but requires deeper Groovy scripting knowledge.

### Plugin Ecosystem

Extensive Library: Jenkins has over 1,500 plugins, making it possible to integrate with almost any tool or service, including SCM tools (Git, SVN), build tools (Maven, Gradle), and cloud services (AWS, GCP).

**Common Plugins:**

1. Git Plugin: For integrating with Git repositories
2. Pipeline Plugin: Enables defining and managing Jenkins pipelines
3. Docker Plugin: For building and deploying Docker containers
4. Blue Ocean: A modern interface for Jenkins with a focus on pipelines

### Jenkins in a CI/CD Pipeline

1. Integration with Version Control: Automatically trigger builds based on commits or pull requests
2. Build Automation: Compile code, run tests, and package applications
3. Artifact Management: Store and manage build artifacts using tools like Artifactory or Nexus
4. Automated Deployment: Deploy applications to staging or production environments automatically or with manual approval gates

# GitLab CI

GitLab CI is a robust and integrated continuous integration and delivery tool that's part of the broader GitLab platform. It allows you to automate your build, test, and deployment pipelines directly from your Git repository.

## Key Concepts:

### Pipelines

A pipeline in GitLab CI consists of a series of stages that define the lifecycle of a CI/CD process (e.g., build, test, deploy).
Pipelines are defined in a `.gitlab-ci.yml` file located in the root directory of your repository.
Each pipeline can run multiple jobs in parallel or sequentially, depending on the configuration.

### Jobs

Jobs are individual tasks within a stage, such as compiling code, running tests, or deploying to a server
Jobs run in a specified environment (e.g., Docker container) and can be configured with different parameters like scripts, artifacts, and tags.

### Stages

Stages organize jobs within a pipeline. Jobs in a stage run concurrently, and the next stage begins only when all jobs in the current stage have completed successfully.
Common stages include build, test, and deploy, but you can customize stages to suit your workflow.

### Runners

GitLab Runners are agents that execute the jobs defined in your pipeline. They can run on various environments, such as virtual machines, Docker containers, or Kubernetes clusters
Runners can be shared (available for all projects) or specific (dedicated to a particular project or group).

### .gitlab-ci.yml File

This file is the heart of GitLab CI, where you define the pipeline structure. Here's a simple example:

```bash
stages:
 - build
 - test
 - deploy
 
build-job:
	stage: build
	script:
	 - echo "Compiling the code"
	 - gcc -o myapp main.c
 
test-job:
	stage: test
	script:
	 - echo "Running tests..."
	 - ./myapp --test
	 
deploy-job:
	stage: deploy
	script:
		- echo "Deploying the application..."
		- scp myapp user@server:/path/to/deploy
	only:
		- main
```

### Key Features

Built-in CI/CD within the GitLab ecosystem
Pipelines as code (using .gitlab-ci.yml)
Supports Docker and Kubernetes integrations
Security testing and monitoring within CI/CD.

# Spinnaker:

Spinnaker is a powerful, open-source continuous delivery platform that focuses on automating and managing the deployment of applications across various cloud environments. Developed by Netflix and later open sourced, Spinnaker excels in multi-cloud deployments and offers sophisticated deployment strategies that help ensure smooth, reliable releases.

### Key Features of Spinnaker

**Multi-Cloud Deployment Support:** Spinnaker is designed to work seamlessly with multiple cloud providers, including AWS, Google Cloud Platform (GCP), Microsoft Azure, Kubernetes, and OpenStack. This makes it a great choice for organizations using or transitioning to a multi-cloud strategy.

### Deployment Strategies

**Canary Releases**: Deploy a new version to a small subset of users before rolling it out to the entire user base, allowing for real-time monitoring and feedback
**Blue/Green Deployments**: Keep two separate environments (blue and green), with one serving live traffic while the other is updated. After the update, traffic is switched to the updated environment
**Rolling Updates**: Gradually replace instances of the current version with the new version, reducing the risk of downtime

**Pipeline Management:**
Spinnaker’s pipelines are highly customizable and can be configured to perform a series of automated steps such as building, testing, and deploying code. It integrates with other CI/CD tools like Jenkins to manage the entire process from code commit to production.
**Application Management:**
Spinnaker provides a unified view of all your applications and their deployments across different environments. This helps teams monitor the status of their applications in real time

**Monitoring and Rollback:**
Spinnaker integrates with monitoring tools like Prometheus and Datadog to keep track of application performance during and after deployment. If issues are detected, Spinnaker can automatically trigger a rollback to the previous stable version, minimizing downtime.
**Extensibility:**
Spinnaker’s microservices architecture allows it to be extended with custom stages, plugins, and integrations. This flexibility enables organizations to tailor the platform to their specific needs

**Spinnaker’s architecture is composed of several microservices, each responsible for a specific aspect of the deployment process:**

**Orca**: Manages the orchestration of pipelines and workflows.
**Clouddriver**: Provides cloud provider-specific functionality, such as creating, deleting, and managing resources
**Deck**: The UI for Spinnaker, allowing users to manage applications, pipelines, and deployments visually 

**Gate**: The API gateway for interacting with Spinnaker
**Igor**: Integrates with CI servers like Jenkins to trigger pipelines based on CI events
**Front50**: Stores the metadata of applications, pipelines, and other Spinnaker objects
**Rosco**: Manages the creation of machine images for cloud deployments
**Echo**: Manages notifications and triggers within Spinnaker

1. Importance of CI:
Continuous Integration (CI) is crucial as it allows developers to frequently merge code changes into a shared repository, automating the build and testing process. This helps identify bugs early, improve collaboration, and speed up development.
2. Introduction to CI Tools (Jenkins, Travis CI, CircleCI) and their advantages:
**Jenkins**: Open-source, highly customizable, with extensive plugin support
**Travis CI**: Cloud-based, simple to set up, integrates well with GitHub
**CircleCI**: Optimized for speed, great for parallel builds, integrates with various services. All tools automate building, testing, and deploying code, improving team efficiency and reducing manual work.
3. Setting Up a CI Pipeline:
A CI pipeline automates the steps of fetching code, running builds, executing tests, and deploying changes.
It helps streamline the development cycle and ensures code is always in a deployable state.
4. Building and Testing Code:
Automating builds and tests in the CI process ensures that code is compiled and tested automatically after each change, ensuring bugs are caught early and code quality is maintained.
5. Artifact Management
Artifacts are the files created during the build process (e.g., compiled binaries, Docker images). CI tools handle storage and management of these artifacts, making them easily retrievable for deployment.
6. Notification and Reporting
CI systems provide notifications (via email, Slack, etc.) and reports on build and test results, keeping teams informed of code status, failures, and successful deployments.
7. Writing Tests for CI, Pipelines, and Workflow
Writing automated tests for the CI pipeline ensures every code change is verified. Unit, integration, and end-to-end tests are integrated into workflows to validate functionality and stability.
8. Different Types of Environments (Beta, Gamma, Prod, Testsuite, OneBox)
**Beta/Gamma**: Pre-production environments for testing features with limited users.
**Prod (Production)**: The live environment where end-users interact with the application.
**Testsuite**: Automated testing environment for running tests.
**OneBox**: A single-instance environment used for testing by developers or for isolated builds.
9. CI Best Practices and Optimizatio
Best practices include frequent commits, fast feedback loops, parallel testing, proper test coverage, and minimizing flaky tests. Optimizing CI involves reducing build time, automating as much as possible, and
ensuring tests run efficiently.

# What is Continuous Deployment?

Continuous deployment (CD) is the practice of automatically deploying code changes to production once they have been tested and approved. CD involves using automation to deploy code changes to production environments as soon as they are ready.
The CD is important because it enables organizations to deliver software faster and more frequently. With CD, code changes can be deployed to production quickly and efficiently, reducing the risk of human error and delays.

1. Faster Time to Market:
- **Immediate Release**: CD enables teams to deploy new features, bug fixes, and improvements to users as soon as they are ready. This rapid deployment capability is essential for businesses that want to stay
competitive and respond quickly to market demands
- **Reduced Lead Time**: By automating the deployment process, CD reduces the time between writing code and getting it into the hands of users, significantly accelerating the development lifecycle.
2. Enhanced Quality and Stability:
- **Automated Testing**: CD pipelines are typically equipped with a suite of automated tests, including unit tests, integration tests, and end-to-end tests. These tests ensure that only code that passes all quality checks is deployed, reducing the risk of introducing bugs into production.
- **Frequent, Smaller Updates**: With CD, updates are smaller and more frequent, which makes it easier to identify and fix issues. Smaller changes are less likely to cause major disruptions, leading to more stable
releases
3. Continuous Feedback and Improvement:
- **Real-Time User Feedback**: CD allows for immediate feedback from users after deploying new features. This feedback can be quickly incorporated into subsequent releases, enabling continuous improvement
- **Monitoring and Analytics**: CD often integrates with monitoring tools that track the performance and behavior of the application in production. This data provides insights that can be used to enhance future updates.
4. Reduced Human Error
- **Automation of Repetitive Tasks**: CD automates repetitive deployment tasks that are prone to human error, such as configuring environments, managing dependencies, and running tests. This reduces the likelihood
of mistakes and ensures consistency across deployments
- **Eliminating Manual Processes**: By removing manual steps, CD minimizes the risk of errors associated with manual interventions, such as incorrect configuration settings or missed deployment steps.
5. Improved Collaboration and DevOps Culture
- Alignment with DevOps Principles: CD aligns with DevOps practices by fostering a culture of collaboration between development, operations, and other stakeholders. It encourages shared ownership of the code,
where everyone is responsible for the success of the deployment process
- Continuous Integration and Delivery: CD works hand-in-hand with Continuous Integration (CI), where code is frequently merged into a shared repository and automatically tested. This synergy promotes a more integrated and collaborative development environment.
6. Scalability and Flexibility:
- Handling Growth: As applications and user bases grow, CD allows for the scalable deployment of updates across multiple environments and regions. Automated deployment pipelines can handle the complexities of deploying to large, distributed systems.
- Flexibility in Deployment Strategies: CD supports various deployment strategies, such as blue-green deployments, canary releases, and rolling updates, giving teams the flexibility to choose the best approach
for their specific needs.
7. Improved Security:
- Security Integration: CD pipelines can integrate security testing and validation steps, ensuring that security checks are automatically performed before code is deployed. This reduces the risk of security vulnerabilities reaching production
-Compliance: Continuous deployment can help maintain compliance with regulatory requirements by ensuring that all deployed code has passed the necessary security and compliance checks.
